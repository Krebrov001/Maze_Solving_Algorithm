
#include "stdafx.h"

#include "helper_functions_header.h"
#include "Game.h"

// using declarations
using std::cout;
using std::cin;
using std::endl;
using std::setw;
using std::setfill;
using std::ios;
using std::ifstream;
using std::string;
using std::to_string;


int main()
{
	// Explicity initialize the properties of the console and return a HANDLE*
	// The HANDLE* allows main() manipulate the properties of the console at runtime.
	HANDLE* Console = initializeConsole();

	// My program uses random numbers.
	// This code is needed to set up the sequence of random numbers.
	//
	srand(static_cast<unsigned int>(time(0)));  // Seed the random number generator.
	rand(); // dispose the first random number, quirk of Visual Studio

	drawLoadingScreen();

	/* Setup the local variables. */

	int gamesPlayed = 0;   // The number of games that had been played to completion.

	string userInput;      // Name of the maze file specified by the user for the current game.

	// Stores the status of the maze map file.
	// 0 - The maze map file was unable to be opened or does not exist.
	// 1 - The maze map file has a wrong format.
	// 2 - The maze map file is good and the game can proceed.
	uint_fast8_t mapFileStatus = 0;

	// These two storage strings save the original state of the Main Menu:
	// the history of the user's interactions with the Main Menu for the previous games.
	//
	string inputStorage;   // Stores the input given by the user for previous games.
	string outputStorage;  // Stores the output generated by the program for previous games.
	// The data for each game is stored inside the storage strings directly followed by a | char.
	// In other words, the | char delimits the input or output data for each game.
	
	// These two iterators are used for writing and reading the input given by the user
	// and the output generated by the program for previous games.
	string::iterator inputLetter  = inputStorage.end();
	string::iterator outputLetter = outputStorage.end();

	// Opens a file specified from the user and reads its contents.
	ifstream reader;

	// This flag becomes true when a game is finished playing.
	// If the game is finshed playing, I want to repaint the Main Menu with the output data,
	// and I want the program to pause for two seconds to give the user some time to read the output
	// before entering new input again.
	bool gameFinished = false;

	/*
	  The main menu loop
	 */
	while (true) {

		system("CLS");  // Clear the screen.
		// Explicitly set the console text to white.
		SetConsoleTextAttribute(*Console, FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY);

		/* The following code prints the Main Menu. */

		cout << endl;
		cout << setw(20) << setfill(' ') << "Main Menu" << endl;

		// Sets the iterators to the beginning of the storage strings,
		// if the storage strings contain some data inside of them.
		if (!inputStorage.empty()) {
			inputLetter = inputStorage.begin();
		}
		if (!outputStorage.empty()) {
			outputLetter = outputStorage.begin();
		}

		/*
		  This code duplicates the user's input and output for the previous maze games to the screen.

		  This is necessary because the screen is overwritten by actual game itself being played,
		  or simply when the user enters invalid input.
		  I then need to restore the original state of the Main Menu somehow, including the
		  data that the user input and the data that the program output for each previous maze game.
		  If that data is duplicated and restored, the Main Menu looks like it is seamless.

		  The user's input for the previous games is stored in the inputStorage string.
		  The program output for the previous games is stored in the outputStorage string.

		  If this is the first game, gamesPlayed == 0,
		  hence there is no input or output in the storage strings and this loop does not execute.

		  Before this loop starts running both iterators are at the start of the storage strings.
		  For each game that was played, data had been written to the storage strings, and the
		  | char was appended to separate the data for each game.

		  A single iteration of this loop duplicates the data saved from exactly one previous game.
		  After printing the standard user prompt,
		  inputLetter iterator prints all the data that the user input for that game,
		  until it hits the | separator.
		  Then the outputLetter iterator prints all the output data for that game,
		  just like the inputLetter iterator does.

		  After each iterator had printed the data for a single iteration of the loop,
		  it now points to the | char in the string.
		  On the next iteration of the loop, the iterator skips the | char and then it prints the
		  data associated with the next game that was played.
		 */
		for (int i = 1; i <= gamesPlayed; ++i) {
			// Print the standard user prompt for each previous game.
			cout << endl;
			cout << setw(5) << setfill(' ') << "";
			cout << "Enter a map file location: (or q to quit)" << endl;
			cout << setw(5) << setfill(' ') << ">";

			// Print the user's input for each previous game.
			if (*inputLetter == '|') {
				++inputLetter;
			}
			while (*inputLetter != '|') {
				cout << *inputLetter;
				++inputLetter;
			}
			cout << endl;

			// Print the program's output for each previous game.
			cout << setw(8) << setfill(' ') << "";
			if (*outputLetter == '|') {
				++outputLetter;
			}
			while (*outputLetter != '|') {
				cout << *outputLetter;
				++outputLetter;
			}
			cout << endl;
		}
		// Now the previous state of the Main Menu with the input and output for previous games
		// has been duplicated/restored to the screen.

		// This code executes if and only if a game has just finished playing.
		// The program execution sleeps for two seconds.
		//
		// This code does not execute if an error message is displayed to the user on invalid input,
		// causing the Main Menu screen to be repainted.
		if (gameFinished) {
			Sleep(2000);
		}
		gameFinished = false;

		// Print the standard user prompt for the current game.
		cout << endl;
		cout << setw(5) << setfill(' ') << "";
		cout << "Enter a map file location: (or q to quit)" << endl;
		cout << setw(5) << setfill(' ') << ">";
		// Get the name of the maze map file for the current game from the user.
		cin >> userInput;

		// q is the command to quit the Main Menu
		// The Main Menu loop breaks and the program exits.
		if (userInput == "q") {
			break;
		}

		mapFileStatus = mapFileFormat_isGood(userInput);

		// If the reader was not able to open the file,
		// or the maze map file had a wrong format,
		// a diagnostic message is printed out to the screen,
		// and then the program execution enters the top of the while (true) {...}
		// Main Menu loop again.
		// It means that the erroneous input is cleared from the screen and the user
		// is prompted to enter another file name.
		if (mapFileStatus == 0) {
			cout << setw(5) << setfill(' ') << "";
			cout << "Error: file not found" << endl;
			Sleep(1500);
		}
		else if (mapFileStatus == 1) {
			cout << setw(5) << setfill(' ') << "";
			cout << "Error: wrong file format" << endl;
			Sleep(1500);
		}
		// If the maze map file is good, then we can read the maze out of it
		// and start the game to be played.
		else if (mapFileStatus == 2) {

			// The filename was good, so save it into the inputStorage string.
			inputStorage.append(userInput);
			inputStorage.push_back('|');

			// Create a dynamic 2-D array to hold the data from the maze map file.
			//
			// gridLocs points to a dynamic array of int*'s of size ROWS,
			// and each int* element in that array points to a dynamic array of ints of size COLUMNS.
			// This is dynamic multi-level arrays in the heap, AKA "ragged" arrays.
			//
			// *(gridLocs + y) is equivalent to gridLocs[y]
			// The former syntax is used to stress the fact that gridLocs is a pointer to int* (or int**)
			// Dereferencing a pointer to int* "knocks off a star", gives me a int*,
			// which is then set to point to a new dynamic array of ints in the heap memory.
			int** gridLocs = new int*[ROWS];
			for (uint_fast8_t y = 0; y != ROWS; ++y) {
				*(gridLocs + y) = new int[COLUMNS];
			}

			// Read the data from the maze map file into the dynamic 2-D array.
			reader.open(userInput);
			for (uint_fast8_t y = 0; y != ROWS; ++y) {
				for (uint_fast8_t x = 0; x != COLUMNS; ++x) {
					reader >> gridLocs[y][x];
				}
			}
			// reader is done reading the file.
			// Close the file and reset the stream flags.
			reader.close();
			reader.clear();

			// Set the text on the console to a random color.
			SetConsoleTextAttribute(*Console, getRandomColor());

			// This code initializes the game before running it.
			// Contains all the methods and data structures for the game.
			Game* game1 = new Game;      // Create a new dynamic Game object.
			game1->setGameStatus(true);  // Start the game.
			game1->readLevel(gridLocs);  // Read the level from the maze map stored in gridLocs 2-D array.
			game1->setAILocation();      // Set the initial location of the AI at the starting position.

			// The data of the maze map grid stored in gridLocs has now been saved into the Game object.
			// We do not need the gridLocs 2-D array.
			// Now Deallocate the dynamic 2-D array.
			//
			// First it loops through the dynamic array of int*'s that gridLocs points to,
			// each int* element points to a dynamic array of ints, which is deleted.
			// Then it deletes the dynamic array of int*'s itseld, and sets gridLocs as a nullptr.
			for (uint_fast8_t y = 0; y != ROWS; ++y) {
				delete[] *(gridLocs + y);
				*(gridLocs + y) = nullptr;
			}
			delete[] gridLocs;
			gridLocs = nullptr;

			// This is the game loop which runs the game.
			// It basically displays the current state of the game,
			// then it calculates the next move and updates the new state of the game,
			// over and over until the game is finished and the game1.getGameStatus returns false.
			while (game1->getGameStatus()) {
				system("CLS");
				game1->PrintLevel();
				game1->nextMove();
				Sleep(1000);
			}

			// Remember that the game is finished now.
			gameFinished = true;
			gamesPlayed++;

			// Now the game is finished running.
			// Now the Game object's internal data is set to the final ready state.
			// The data is retrieved from the Game object and it is saved into the outputStorage string.
			// a | char is appended to the end of the data to delimit it from data which is
			// saved in future games.
			if (game1->getMazeSolved()) {
				outputStorage.append("Maze was solved. Steps taken: ");
				outputStorage.append(to_string(game1->getSteps()));
				outputStorage.push_back('|');
			}
			else {
				outputStorage.append("This maze is unsolveable.");
				outputStorage.push_back('|');
			}

			// The game is over now.
			// Deallocate the new dynamically created Game object.
			delete game1;

		}
		else {
			cout << setw(5) << setfill(' ') << "";
			cout << "Error: It's a glitch in the Matrix!" << endl;
			Sleep(1500);
		}

	} // while (true) main menu

	// Delete the dynamic HANDLE object which was created inside initializeConsole()
	delete Console;

	// end of program
	return EXIT_SUCCESS;
}